#ifndef PROCEDURALPLACEMENTLIB_PLACEMENT_RESULT_HPP
#define PROCEDURALPLACEMENTLIB_PLACEMENT_RESULT_HPP

#include "glutils/buffer.hpp"
#include "glutils/sync.hpp"

#include <chrono>
#include <utility>

namespace placement {

/**
 * @brief Wraps a buffer containing placement results.
 * A result buffer is composed of "count" and "value" sections. The count section specifies the number of valid elements
 * generated by the placement operation, while the value section contains said elements. Note that the size of these
 * two sections does not necessarily add up to the size of the buffer; there is unused space after the value section.
 *
 * The count section begins at the start of the buffer, and consists of an array of 32-bit unsigned integers containing
 * num_classes elements, one for each placement class. These values represent the number of valid elements for each
 * class, that is, the value at index i is the number of valid elements in class i.
 *
 * The value section is an array of valid elements, each one composed of a 3-element vector of 32-bit floating point
 * values (vec3) followed by a single 32-bit unsigned integer (uint). The vector corresponds to the position of the
 * element in world space, while the integer is the class index. The array is sorted in ascending order of class index.
 * This means that the first element of class 0 is at position 0 and the last element is at position count[0] - 1 of the
 * array. Elements of class 1 are located in the range [count[0], count[0] + count[1]), and so on for each additional
 * class.
 */
class ResultBuffer final
{
public:
    using GLsizeiptr = GL::GLsizeiptr;

    GLsizeiptr size;        //<! Total size of the buffer, in bytes.
    GLsizeiptr num_classes; //<! Number of placement classes in the buffer.
    GL::Buffer gl_object;      //<! GL buffer object.
};

class FutureResult final
{
public:
    FutureResult(GL::Buffer&& buffer, GL::Sync&& sync);

    [[nodiscard]]
    bool isReady() const { return wait(std::chrono::nanoseconds::zero()); }

    [[nodiscard]]
    bool wait(std::chrono::nanoseconds timeout) const;

    [[nodiscard]]
    GL::BufferHandle getBuffer() const;

    GL::Buffer moveBuffer() { return std::move(m_buffer); }

private:
    GL::Buffer m_buffer;
    GL::Sync m_sync;
};

class PlacementResult
{

};

} // placement

#endif //PROCEDURALPLACEMENTLIB_PLACEMENT_RESULT_HPP
